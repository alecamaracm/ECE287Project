using GemBox.Presentation;
using Microsoft.VisualBasic;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace PowerPointVerilogEngineDesigner
{
    public partial class Form1 : Form
    {
        PresentationDocument mainDocument;
        List<PresentationDocument> referenceDocuments = new List<PresentationDocument>();

        string currentProjectFilePath = "";
        string currentProjectFolderPath = "";

        bool isUpdated = true;
        FileSystemWatcher watcher = new FileSystemWatcher();

        List<string> arrowMovings = new List<string>();
        List<string> wasdMovings = new List<string>();
        List<string> bouncings = new List<string>();

        Dictionary<string,MovingProperties> movingProperties = new Dictionary<string,MovingProperties>();

        List<MemoryBitmaps> bitmapsToWrite = new List<MemoryBitmaps>();

        bool working = false;

        public Form1(bool upd)
        {
            isUpdated = !upd;
            InitializeComponent();
            Console.SetOut(new MultiTextWriter(new ControlWriter(textBoxOutput), Console.Out));
            ComponentInfo.SetLicense("FREE-LIMITED-KEY");
        }

        private void button1_Click(object sender, EventArgs e)
        {
           
            if (working == true) return;
            if(currentProjectFilePath=="")
            {
                Interaction.MsgBox("Please select a project or create one first", MsgBoxStyle.Exclamation);
                return;
            }
            if (isUpdated == false) Interaction.MsgBox("UPDATE, UPDATE, UPDATE, EXTERMINATE",MsgBoxStyle.Critical);

            if (checkBoxClearLog.Checked) textBoxOutput.Clear();
            pictureBox1.Visible = true;
            working = true;
            Task.Run(() => {
                movingProperties.Clear();
                wasdMovings.Clear();
                arrowMovings.Clear();
                bitmapsToWrite.Clear();
                Stopwatch watch = new Stopwatch();
                watch.Start();
                Console.WriteLine("Loading PowerPoint document main.pptx...");
                mainDocument = PresentationDocument.Load(currentProjectFolderPath + "\\PPVerilogEngine\\main.pptx");
                Console.WriteLine("Loaded PowerPoint document main.pptx!");

                using (StreamWriter writer = new StreamWriter(currentProjectFolderPath + "\\IH8Verilog_main.v"))
                {
                    List<string> movs=getMovableVarNames(mainDocument.Slides[0]);
                    Console.WriteLine("Writing main module definition...");
                    writer.WriteLine("\n//--  This file was automatically generated by the PowerPoint2Verilog compiler. Please do not change anything and use the compiler instead --//\n");
                    writer.WriteLine("module PP2VerilogDrawingController(CLOCK,animationCLOCK,wasd,arrows,xPixel,yPixel,VGAr,VGAg,VGAb,mouseX,mouseY"+((movs.Count>0)?",":"") + String.Join(",",movs.ToArray())+");" + Environment.NewLine);

                    writer.WriteLine("input CLOCK;");
                    writer.WriteLine("input animationCLOCK;");
                    writer.WriteLine("input [3:0]wasd;");
                    writer.WriteLine("input [3:0]arrows;");
                    writer.WriteLine("input [9:0]xPixel;" + Environment.NewLine + "input[8:0]yPixel;");
                    writer.WriteLine("input [10:0]mouseX;");
                    writer.WriteLine("input [10:0]mouseY;");
                    writer.WriteLine("output [7:0]VGAr;");
                    writer.WriteLine("output [7:0]VGAg;");
                    writer.WriteLine("output [7:0]VGAb;");
                    writer.WriteLine("reg [7:0]VGAr;");
                    writer.WriteLine("reg [7:0]VGAg;");
                    writer.WriteLine("reg [7:0]VGAb;");
                    writer.WriteLine("reg [15:0]buffer;");

                    foreach(String s in movs)
                    {
                        writer.WriteLine("input [9:0]"+s+";");
                    }
                    writer.WriteLine();

                    writer.WriteLine("always @(*)");
                    writer.WriteLine("begin\n");

                    Console.WriteLine("Compiling and writing first slide...");
                    if (mainDocument.Slides.Count > 0) writeSlide(mainDocument.Slides[0], 1, writer);


                    writer.WriteLine("\nend\n");

                    foreach (String s in arrowMovings)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }
                    foreach (String s in wasdMovings)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }
                    foreach (String s in bouncings)
                    {
                        writer.WriteLine("wire [9:0]" + s + ";");
                    }



                    writer.WriteLine();
                    if (arrowMovings.Count > 0 || wasdMovings.Count > 0)
                    {
                        writer.WriteLine("\nanimations anim1(animationCLOCK,wasd,arrows," + String.Join(",", bouncings.ToArray()) + ","+ String.Join(",", arrowMovings.ToArray()) + "," + String.Join(",", wasdMovings.ToArray()) + ");");
                    }

                    foreach (MemoryBitmaps m in bitmapsToWrite)
                    {
                        writer.WriteLine("wire [14:0]" + m.name + "q;");
                        writer.WriteLine(String.Format("ram{0} {0}ram((((yPixel-{0}Y)/{2})*{1} +((xPixel-{0}X)/{2})+1),CLOCK,15'd0,0,{0}q);",
                            m.name,m.reducedBitmap.Width,m.scale));


                        Console.WriteLine("\tCreating memory initialization file for: " + m.name+"... ("+m.size+" words)");

                        long count = 0;
                        ulong[] array = new ulong[m.size];
                        for (int j = 0; j < m.reducedBitmap.Height; j++)
                        {
                            for (int i = 0; i < m.reducedBitmap.Width; i++)
                            {
                                ulong hugeColor = 0;
                                ulong rColor = (byte)(m.reducedBitmap.GetPixel(i, j).R / 8);
                                hugeColor = hugeColor + (rColor << 10);
                                ulong gColor = (byte)(m.reducedBitmap.GetPixel(i, j).G / 8);
                                hugeColor = hugeColor + (gColor << 5);
                                ulong bColor = (byte)(m.reducedBitmap.GetPixel(i, j).B / 8);
                                hugeColor = hugeColor + (bColor << 0);
                                array[count] = hugeColor;
                                count += 1;
                            }
                        }

                        using (StreamWriter writer2 = new StreamWriter(new FileInfo(currentProjectFilePath).Directory+ "\\memInitialization\\ram"+m.name+".mif"))
                        {
                            writer2.WriteLine("DEPTH = " + array.Length + ";");
                            writer2.WriteLine("WIDTH = 15;");
                            writer2.WriteLine("ADDRESS_RADIX = DEC;");
                            writer2.WriteLine("DATA_RADIX = DEC;");
                            writer2.WriteLine("CONTENT");
                            writer2.WriteLine("BEGIN ");
                            for (int i = 0; i < array.Length; i++)
                            {
                                writer2.WriteLine(i + ":" + array[i] + ";");
                            }
                            writer2.WriteLine("END;");
                        }
                    }


                    writer.WriteLine(Environment.NewLine + "endmodule");

                    if(arrowMovings.Count>0 || wasdMovings.Count>0 || bouncings.Count > 0)
                    {
                        writeAnimationModule(mainDocument.Slides[0],writer);
                    }

                    watch.Stop();
                    Console.WriteLine("Compilation finished. Took {0}s.",watch.ElapsedMilliseconds/1000.0f);

                }


                working = false;
            });

            Task.Run(() => {
                Thread.Sleep(7500);
                this.Invoke((MethodInvoker)delegate () {
                    pictureBox1.Visible = false;
                });

            });
        }

        private void writeAnimationModule(Slide slide,StreamWriter writer)
        {
            writer.WriteLine("\nmodule animations(animationCLOCK,wasd,arrows," +  String.Join(",", bouncings.ToArray())+","+ String.Join(",",arrowMovings.ToArray())+","+ String.Join(",", wasdMovings.ToArray()) + ");\n");

            foreach (String s in arrowMovings)
            {
                writer.WriteLine("output [9:0]" + s + ";");
                writer.WriteLine("reg [9:0]" + s + ";");
            }
            foreach (String s in wasdMovings)
            {
                writer.WriteLine("output [9:0]" + s + ";");
                writer.WriteLine("reg [9:0]" + s + ";");
            }
            foreach (String s in bouncings)
            {
                writer.WriteLine("output [9:0]" + s + ";");
                writer.WriteLine("reg [9:0]" + s + ";");
                writer.WriteLine("reg "+s+"Dir;");
            }

            writer.WriteLine("input animationCLOCK;");
            writer.WriteLine("input [3:0]arrows;");
            writer.WriteLine("input [3:0]wasd;");

            writer.WriteLine("\nalways @ (posedge animationCLOCK)");
            writer.WriteLine("begin");

           /* foreach (String s in arrowMovings)
            {
                writer.WriteLine("input [9:0]" + s + ";");

            }*/
            foreach (String s in wasdMovings)
            {
                if (s.EndsWith("X")) writer.WriteLine(getTabs(1)+"//Writing WASD movement for " + s+":");
                MovingProperties properties = movingProperties[s.Substring(0,s.Length-1)];
                if(s.EndsWith("X"))
                {
                    writer.WriteLine(getTabs(1) + "if(wasd[1]==1 && " + s + ">0) " + s + "=" + s + "-"+properties.speed+";");
                    writer.WriteLine(getTabs(1) + "if (wasd[3] == 1 && " + s + " < 640 - " + properties.width + ") " + s + " = " + s + " + " + properties.speed + ";");
                }
                else
                {
                    writer.WriteLine(getTabs(1) + "if(wasd[0]==1 && "+s+">0) "+s+"="+s+ "-" + properties.speed + ";");
                    writer.WriteLine(getTabs(1) + "if(wasd[2]==1 && " + s + "<480-" + properties.height + ") " + s + "=" + s + "+" + properties.speed + ";");
                }
            }

            writer.WriteLine();

            foreach (String s in arrowMovings)
            {
                if (s.EndsWith("X")) writer.WriteLine(getTabs(1) + "//Writing ARROWS movement for " + s + ":");
                MovingProperties properties = movingProperties[s.Substring(0, s.Length - 1)];
                if (s.EndsWith("X"))
                {
                    writer.WriteLine(getTabs(1) + "if(arrows[1]==1 && " + s + ">0) " + s + "=" + s + "-" + properties.speed + ";");
                    writer.WriteLine(getTabs(1) + "if (arrows[3] == 1 && " + s + " < 640 - " + properties.width + ") " + s + " = " + s + " + " + properties.speed + ";");
                }
                else
                {
                    writer.WriteLine(getTabs(1) + "if(arrows[0]==1 && " + s + ">0) " + s + "=" + s + "-" + properties.speed + ";");
                    writer.WriteLine(getTabs(1) + "if(arrows[2]==1 && " + s + "<480-" + properties.height + ") " + s + "=" + s + "+" + properties.speed + ";");
                }
            }

            writer.WriteLine();

            foreach (String s in bouncings)
            {
                if (s.EndsWith("X")) writer.WriteLine(getTabs(1) + "//Writing Bouncing movement for " + s + ":");
                MovingProperties properties = movingProperties[s.Substring(0, s.Length - 1)];
                writer.WriteLine("\tif("+s+"Dir==1)");
                writer.WriteLine("\tbegin");
                if(s.EndsWith("X"))
                {
                    writer.WriteLine("\t\tif (" + s + " >= 640 - " + properties.width + ")");
                }
                else
                {
                    writer.WriteLine("\t\tif (" + s + " >= 480 - " + properties.height + ")");
                }
     
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + "Dir = 0;");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\t\telse");
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + " <= " + s + " + " + properties.speed + ";");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\tend");
                writer.WriteLine("\telse");
                writer.WriteLine("\tbegin");
                writer.WriteLine("\t\tif (" + s + " <= 0)");
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + "Dir = 1;");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\t\telse");
                writer.WriteLine("\t\tbegin");
                writer.WriteLine("\t\t\t" + s + " <= " + s + " - " + properties.speed + ";");
                writer.WriteLine("\t\tend");
                writer.WriteLine("\tend");
            }

            writer.WriteLine("end");

            writer.WriteLine("\nendmodule");
        }

        void writeSlide(Slide slide,int tabs,StreamWriter writer)
        {
            Console.WriteLine(getTabs(1) + "Reading properties from slide:");
            Dictionary<string, string> slideProperties=new Dictionary<string, string>();
            if(slide.Notes!=null)
            {
                slideProperties=getProperties(slide.Notes.Content.Drawings.OfType<Shape>().Single(sp => sp.Placeholder.PlaceholderType == PlaceholderType.Text).Text);                
            }

            for(int i=0;i<slideProperties.Values.Count;i++)
            {
                Console.WriteLine(getTabs(2) + slideProperties.Keys.ElementAt(i) + " = " + slideProperties.Values.ElementAt(i));
            }

            //Background color
            System.Drawing.Color backColor = System.Drawing.Color.White;  
            if (slideProperties.ContainsKey("BACKCOLOR"))
            {
                backColor = parseColor(slideProperties["BACKCOLOR"]);                
            }
            

            writer.WriteLine(getTabs(tabs)+"//Writing backgound color");
            writer.WriteLine(getTabs(tabs)+"VGAr = " + formatNumber("b", 8, Convert.ToString(backColor.R, 2).PadLeft(8, '0')) + ";");
            writer.WriteLine(getTabs(tabs)+"VGAg = " + formatNumber("b", 8, Convert.ToString(backColor.G, 2).PadLeft(8, '0')) + "; ");
            writer.WriteLine(getTabs(tabs)+"VGAb = " + formatNumber("b", 8, Convert.ToString(backColor.B, 2).PadLeft(8, '0')) + "; ");

            Console.WriteLine(getTabs(1) + "Writing basic shapes...");
            drawBasicShapes(writer, mainDocument.Slides[0],tabs);

            Console.WriteLine(getTabs(1) + "Writing pictures...");
            drawBasicPictures(writer,mainDocument.Slides[0],tabs);
        }

        private void drawBasicPictures(StreamWriter writer, Slide slide, int tabs)
        {
            //Draw pictures
            foreach (Picture picture in slide.Content.Drawings.OfType<Picture>())
            {
                if (picture.DrawingType == DrawingType.Picture)
                {
                    Dictionary<string, string> properties = getProperties(null, picture.AlternativeText.Description);

                    Console.WriteLine(getTabs(2) + "Writing picture: " + (properties.ContainsKey("NAME") ? properties["NAME"] : (properties.ContainsKey("CURSOR") ? "Mouse" : "UNNAMED")));

                    //Transparency only valid for in-memory pictures;
                    int allowedTransparencyLevel = 0;
                    if (properties.ContainsKey("TRANSPARENT")) allowedTransparencyLevel = 1;
                    if (properties.ContainsKey("ADVANCEDTRANSPARENT")) allowedTransparencyLevel = 2;

                    int compresionFactor = 1;
                    int maxColorBits = 8;
                    if (properties.ContainsKey("COMPRESIONLEVEL")) compresionFactor = int.Parse(properties["COMPRESIONLEVEL"]);
                    if (properties.ContainsKey("COLORBITS")) maxColorBits = int.Parse(properties["COLORBITS"]);
                    Bitmap baseBitmap = new Bitmap(picture.Fill.Data.Content.Open());
                    if (Directory.Exists(currentProjectFolderPath + "/PPVerilogEngine//tempPictures") == false) Directory.CreateDirectory(currentProjectFolderPath + "/PPVerilogEngine//tempPictures");
                    baseBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//basePicture.png");
                    DrawingLayout finalLayout = getScaledLayout(picture.Layout);

                    if(properties.ContainsKey("MEMORY"))
                    {
                        Bitmap resizedBitmap = new Bitmap(baseBitmap, new Size((int)(finalLayout.Width / compresionFactor), (int)(finalLayout.Height / compresionFactor)));
                        resizedBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//memcompressedPicture.png");
                        maxColorBits = 5;
                        Bitmap colorSetBitmap = new Bitmap(resizedBitmap);
                        colorSetBitmap = limitColorBitmap(colorSetBitmap, maxColorBits);
                        colorSetBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//memcolorLimitedPicture.png");
                        MemoryBitmaps memoryBitmaps = new MemoryBitmaps() { reducedBitmap = colorSetBitmap };
                        if (properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME"))
                        {
                            memoryBitmaps.x=properties["NAME"].Replace(" ", "_") + "X";
                            memoryBitmaps.y=properties["NAME"].Replace(" ", "_") + "Y";
                        }else
                        {
                            memoryBitmaps.x = ((int)(finalLayout.Left.To(LengthUnit.Point))).ToString();
                            memoryBitmaps.y = ((int)(finalLayout.Top.To(LengthUnit.Point))).ToString();
                        }
                        memoryBitmaps.name = properties["NAME"].Replace(" ", "_");
                        memoryBitmaps.scale = compresionFactor;

                        memoryBitmaps.size = memoryBitmaps.reducedBitmap.Width * memoryBitmaps.reducedBitmap.Height;
                        bitmapsToWrite.Add(memoryBitmaps);
                        writer.WriteLine();
                        writer.WriteLine(getTabs(tabs) + String.Format("if(yPixel>={0}Y && yPixel<{0}Y+({2}*{1}) && xPixel>={0}X && xPixel<{0}X+({3}*{1}))", properties["NAME"].Replace(" ", "_"), compresionFactor, (int)(finalLayout.Height / compresionFactor), (int)(finalLayout.Width / compresionFactor)));
                        writer.WriteLine("\tbegin");


                        if (allowedTransparencyLevel == 0)  //No transparency allowed
                        {
                            writer.WriteLine(getTabs(1 + tabs) + "VGAr=" + properties["NAME"].Replace(" ", "_") + "q[14:10]*8;");
                            writer.WriteLine(getTabs(1 + tabs) + "VGAg=" + properties["NAME"].Replace(" ", "_") + "q[9:5]*8;");
                            writer.WriteLine(getTabs(1 + tabs) + "VGAb=" + properties["NAME"].Replace(" ", "_") + "q[4:0]*8;");
                        }
                        else
                        {
                            if (allowedTransparencyLevel == 1)  //Basic transparency (50/50) allowed
                            {
                                writer.WriteLine(getTabs(1 + tabs) + "VGAr=(VGAr+" + properties["NAME"].Replace(" ", "_") + "q[14:10]*8)/2;");
                                writer.WriteLine(getTabs(1 + tabs) + "VGAg=(VGAg+" + properties["NAME"].Replace(" ", "_") + "q[9:5]*8)/2;");
                                writer.WriteLine(getTabs(1 + tabs) + "VGAb=(VGAb+" + properties["NAME"].Replace(" ", "_") + "q[4:0]*8)/2;");
                            }                        
                            else  //Custom color based trnasparency allowed
                            {
                                int transLevel = int.Parse(properties["ADVANCEDTRANSPARENT"]);
                                writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + "("+memoryBitmaps.name+"q[14:10]*8) *" + (100- transLevel) + "+"+ transLevel+ " * VGAr) / 100;");
                                writer.WriteLine(getTabs(tabs + 1) + "VGAg= (" + "(" + memoryBitmaps.name + "q[9:5]*8) *" + (100 - transLevel) + "+" + transLevel + " * VGAg) / 100;");
                                writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + "(" + memoryBitmaps.name + "q[4:0]*8) *" + (100 - transLevel) + "+" + transLevel + " * VGAb) / 100;");
                            }
                        }

                        if (properties.ContainsKey("WASDMovement") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                        {
                            int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                            wasdMovings.Add(properties["NAME"].Replace(" ", "_") + "X");
                            wasdMovings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                            movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = resizedBitmap.Height*compresionFactor, width = resizedBitmap.Width * compresionFactor, name = properties["NAME"].Replace(" ", "_"), speed = sp });
                        }

                        if (properties.ContainsKey("ARROWSMovement") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                        {
                            int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                            arrowMovings.Add(properties["NAME"].Replace(" ", "_") + "X");
                            arrowMovings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                            movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = resizedBitmap.Height * compresionFactor, width = resizedBitmap.Width * compresionFactor, name = properties["NAME"].Replace(" ", "_"), speed = sp });
                        }

                        if (properties.ContainsKey("BOUNCING") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                        {
                            int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                            bouncings.Add(properties["NAME"].Replace(" ", "_") + "X");
                            bouncings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                            movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = resizedBitmap.Height * compresionFactor, width = resizedBitmap.Width * compresionFactor, name = properties["NAME"].Replace(" ", "_"), speed = sp });
                        }


                        writer.WriteLine("\tend");
                        



                        Console.WriteLine(getTabs(3) + "Picture from memory: "+ (properties.ContainsKey("NAME") ? properties["NAME"] : "UNNAMED"));
                    }
                    else if(properties.ContainsKey("CURSOR"))
                    {
                        Size size = new Size(10, 10);
                        if (properties.ContainsKey("CURSOR-SIZE")) size = new Size(int.Parse(properties["CURSOR-SIZE"].Split(',')[0]), int.Parse(properties["CURSOR-SIZE"].Split(',')[1]));

                        Bitmap resizedBitmap = new Bitmap(baseBitmap,size);
                        resizedBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//compressedPicture.png");

                        Bitmap colorSetBitmap = new Bitmap(resizedBitmap);
                        colorSetBitmap = limitColorBitmap(colorSetBitmap, maxColorBits);
                        colorSetBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//colorLimitedPicture.png");

                        int savedPixels = 0;
                        int usedPixels = 0;
                        writer.WriteLine(Environment.NewLine + getTabs(tabs) + "//Drawing mouse: ");
                        for (int i = 0; i < colorSetBitmap.Height; i++)
                        {
                            int startingPixel = -1;
                            var startingColor = System.Drawing.Color.White;
                            for (int j = 0; j < colorSetBitmap.Width; j++)
                            {
                                System.Drawing.Color color = colorSetBitmap.GetPixel(j, i);
                                if (color.A > 100)
                                {
                                    if (startingPixel == -1)
                                    {
                                        startingPixel = j;
                                        startingColor = color;
                                    }
                                    else
                                    {
                                        if ((color.R != startingColor.R || color.G != startingColor.G || color.B != startingColor.B) || j == colorSetBitmap.Width - 1) //Not the same, write the old one  || From startingPixel to current-1 in width (j)
                                        {
                                            writer.Write(getTabs(tabs) + "if(yPixel>=(mouseY+" + (int)((i * compresionFactor)) + ") && yPixel<(mouseY+" + (int)(((i + 1) * compresionFactor)) + ") && xPixel>=(mouseX+" + (int)((startingPixel * compresionFactor)) + ") && xPixel<(mouseX+" + (int)((j * compresionFactor)) + ")) ");

                                            writer.WriteLine("{VGAr,VGAg,VGAb}={" + formatNumber("b", 8, Convert.ToString(startingColor.R, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.G, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.B, 2).PadLeft(8, '0')) + "};");

                                            startingColor = color;
                                            startingPixel = j;
                                            usedPixels++;
                                        }
                                        else
                                        {
                                            savedPixels++;
                                            //Do nothing, is still the same color, keep waiting until it changes.
                                        }
                                    }
                                }
                            }
                        }

                        Console.WriteLine(getTabs(3) + "Mouse drawn at " + Math.Round((float)usedPixels / (baseBitmap.Width * baseBitmap.Height) * 100, 2) + "% of the original size!");

                    }
                    else
                    {
                        Bitmap resizedBitmap = new Bitmap(baseBitmap, new Size((int)(finalLayout.Width / compresionFactor), (int)(finalLayout.Height / compresionFactor)));
                        resizedBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//compressedPicture.png");

                        Bitmap colorSetBitmap = new Bitmap(resizedBitmap);
                        colorSetBitmap = limitColorBitmap(colorSetBitmap, maxColorBits);
                        colorSetBitmap.Save(currentProjectFolderPath + "/PPVerilogEngine//tempPictures//colorLimitedPicture.png");

                        int savedPixels = 0;
                        int usedPixels = 0;
                        writer.WriteLine(Environment.NewLine + getTabs(tabs) + "//Drawing picture with compression rate: " + compresionFactor + ":1");
                        for (int i = 0; i < colorSetBitmap.Height; i++)
                        {
                            int startingPixel = -1;
                            var startingColor = System.Drawing.Color.White;
                            for (int j = 0; j < colorSetBitmap.Width; j++)
                            {
                                System.Drawing.Color color = colorSetBitmap.GetPixel(j, i);
                                if (color.A > 100)
                                {
                                    if (startingPixel == -1)
                                    {
                                        startingPixel = j;
                                        startingColor = color;
                                    }
                                    else
                                    {
                                        if ((color.R != startingColor.R || color.G != startingColor.G || color.B != startingColor.B) || j == colorSetBitmap.Width - 1) //Not the same, write the old one  || From startingPixel to current-1 in width (j)
                                        {
                                      
                                                writer.Write(getTabs(tabs) + "if(yPixel>=" + (int)(finalLayout.Top + (i * compresionFactor)) + " && yPixel<" + (int)(finalLayout.Top + ((i + 1) * compresionFactor)) + " && xPixel>=" + (int)(finalLayout.Left + (startingPixel * compresionFactor)) + " && xPixel<" + (int)(finalLayout.Left + (j * compresionFactor)) + ") ");
                                                writer.WriteLine("{VGAr,VGAg,VGAb}={" + formatNumber("b", 8, Convert.ToString(startingColor.R, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.G, 2).PadLeft(8, '0')) + "," + formatNumber("b", 8, Convert.ToString(startingColor.B, 2).PadLeft(8, '0')) + "};");

                                            

                                            startingColor = color;
                                            startingPixel = j;
                                            usedPixels++;
                                        }
                                        else
                                        {
                                            savedPixels++;
                                            //Do nothing, is still the same color, keep waiting until it changes.
                                        }
                                    }
                                }
                            }
                        }

                        Console.WriteLine(getTabs(3) + "Picture compressed at " + Math.Round((float)usedPixels / (baseBitmap.Width * baseBitmap.Height) * 100, 2) + "% of the original size!");
                    }

                }
            }
        }

        private Dictionary<string, string> getProperties(GemBox.Presentation.TextBox notes,string fromString="")
        {
            Dictionary<string, string> toReturn = new Dictionary<string, string>();
            string finalNotes = "";
            if (fromString=="")
            {
                if (notes == null) return toReturn;
                
                foreach (var line in notes.Paragraphs)
                {
                    foreach (var text in line.Elements)
                    {
                        string property = text.ToString();
                        finalNotes += property;

                    }
                }
            }else
            {
                finalNotes = fromString;
            }

            finalNotes = finalNotes.Replace("\n", "");

            List<string> properties = new List<string>();
            if(finalNotes.Contains(";"))
            {
                properties = finalNotes.Split(';').ToList();
            }
            else
            {
                properties.Add(finalNotes);
            }

            foreach (string propertyx in properties)
            {
                string property = propertyx;
                if (property.Contains("[") && property.Contains("]") && property.StartsWith("//") == false)
                {
                    property = property.Replace("[", "").Replace("]", "");
                    if (property.Contains("="))
                    {
                        toReturn.Add(property.Split('=')[0].Replace(" ",""), property.Split('=')[1].Replace(" ", ""));
                    }
                    else
                    {
                        toReturn.Add(property.Replace(" ", ""), "");
                    }
                   // Console.WriteLine("Property found: " + property);
                }
            }



            return toReturn;
        }

        private void drawBasicShapes(StreamWriter writer, Slide slide,int tabs)
        {
            //Draw shapes
            foreach(Shape shape in slide.Content.Drawings.OfType<Shape>())
            {
                Dictionary<string, string> properties = getProperties(shape.Text);
                if(shape.Format.Fill.FillType==FillFormatType.Solid)
                {
                    SolidFillFormat f = (SolidFillFormat)shape.Format.Fill;

                    //Find level of transparency
                    int allowedTransparencyLevel = 0;
                    if (properties.ContainsKey("TRANSPARENT")) allowedTransparencyLevel = 1;
                    if (properties.ContainsKey("ADVANCEDTRANSPARENT")) allowedTransparencyLevel = 2;

                    if (shape.ShapeType==ShapeGeometryType.Rectangle)
                    {
                        Console.WriteLine(getTabs(2) + "Writing solid shape: "+(properties.ContainsKey("NAME") ? properties["NAME"] : "UNNAMED"));


                        writer.WriteLine(Environment.NewLine + getTabs(tabs) + "//Drawing Solid shape \"" + (properties.ContainsKey("NAME")?properties["NAME"]:"UNNAMED") +"\"");                      
                        if (properties.ContainsKey("TRANSPARENT")) writer.WriteLine(getTabs(tabs)+"//   --> Allowed 50% transparent render");
                        if (properties.ContainsKey("ADVANCEDTRANSPARENT")) writer.WriteLine(getTabs(tabs) + "//   --> Allowed advanced transparent render");

                        getScaledLayout(shape.Layout);

                        //Draw shapes
                        if (properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME"))
                        {
                            writeSquareShapeColorMoveable(writer, f.Color, shape.Layout, tabs, shape.Format.Outline, properties.ContainsKey("BORDER"), allowedTransparencyLevel, properties["NAME"].Replace(" ", "_"));
                        } else
                        {
                            writeSquareShapeColor(writer, f.Color, shape.Layout, tabs, shape.Format.Outline, properties.ContainsKey("BORDER"), allowedTransparencyLevel);
                        }
                        if (properties.ContainsKey("WASDMovement") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                        {
                            int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]): 1;
                            wasdMovings.Add(properties["NAME"].Replace(" ", "_") + "X");
                            wasdMovings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                            movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height= (int)shape.Layout.Height.To(LengthUnit.Point), width= (int)shape.Layout.Width.To(LengthUnit.Point), name=properties["NAME"].Replace(" ", "_"), speed=sp});
                        }
                          
                        if (properties.ContainsKey("ARROWSMovement") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                        {
                            int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                            arrowMovings.Add(properties["NAME"].Replace(" ", "_") + "X");
                            arrowMovings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                            movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = (int)shape.Layout.Height.To(LengthUnit.Point), width = (int)shape.Layout.Width.To(LengthUnit.Point), name = properties["NAME"].Replace(" ", "_"), speed = sp });

                        }

                        if (properties.ContainsKey("BOUNCING") && properties.ContainsKey("NAME") && properties.ContainsKey("MOVEABLE"))
                        {
                            int sp = properties.ContainsKey("AnimationSpeed") ? int.Parse(properties["AnimationSpeed"]) : 1;
                            bouncings.Add(properties["NAME"].Replace(" ", "_") + "X");
                            bouncings.Add(properties["NAME"].Replace(" ", "_") + "Y");
                            movingProperties.Add(properties["NAME"].Replace(" ", "_"), new MovingProperties() { height = (int)shape.Layout.Height.To(LengthUnit.Point), width = (int)shape.Layout.Width.To(LengthUnit.Point), name = properties["NAME"].Replace(" ", "_"), speed = sp });
                        }



                    }                    
                }
            }

            
        }

        private Bitmap limitColorBitmap(Bitmap colorSetBitmap,int bitLimit)
        {
            int dividend = (int)(256 / (Math.Pow(2,bitLimit-1)));

            for(int i=0;i<colorSetBitmap.Width;i++)
            {
                for(int j=0;j<colorSetBitmap.Height;j++)
                {
                    System.Drawing.Color color = colorSetBitmap.GetPixel(i, j);
                    int r = (int)(Math.Round((double)color.R / dividend, 0) * dividend);
                    int g = (int)(Math.Round((double)color.G / dividend, 0) * dividend);
                    int b = (int)(Math.Round((double)color.B / dividend, 0) * dividend);
                    if (r > 255) r = 255;
                    if (g > 255) g = 255;
                    if (b > 255) b = 255;
                    color = System.Drawing.Color.FromArgb(color.A,r,g ,b);
                    colorSetBitmap.SetPixel(i,j,color);
                }
            }

            return colorSetBitmap;
        }

        System.Drawing.Color parseColor(string colorString)
        {
            try
            {
                if (colorString.StartsWith("#"))
                {
                    return System.Drawing.Color.FromArgb(255, 255, 255);
                }
                else
                {
                    return System.Drawing.Color.FromArgb(int.Parse(colorString.Split(',')[0]), int.Parse(colorString.Split(',')[1]), int.Parse(colorString.Split(',')[2]));
                }
            }catch(Exception ex)
            {
                Console.WriteLine("An error has occurred when parsing color {0}. {1}", colorString, ex.Message);
                return System.Drawing.Color.White;
            }
           
        }

        string getTabs(int number)
        {
            string toReturn="";

            for (int i = 0; i < number; i++) toReturn += "\t";

            return toReturn;
        }

        DrawingLayout getScaledLayout(DrawingLayout layout)
        {         
            layout.Left = ((layout.Left / 72.0) / 10) * 640;
            layout.Width = ((layout.Width / 72.0) / 10) * 640;
            layout.Top = ((layout.Top / 72.0) / 7.5) * 480;
            layout.Height = ((layout.Height / 72.0) / 7.5) * 480;
            return layout;


        }

       
        public List<string> getMovableVarNames(Slide slide)
        {
            List<string> toReturn = new List<string>();

            foreach (Shape shape in slide.Content.Drawings.OfType<Shape>())
            {
                Dictionary<string, string> properties = getProperties(shape.Text);
                if(properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME") && properties.ContainsKey("WASDMovement")==false && properties.ContainsKey("ARROWSMovement")==false &&   properties.ContainsKey("BOUNCING") == false)
                {
                    toReturn.Add(properties["NAME"].Replace(" ","_") + "X");
                    toReturn.Add(properties["NAME"].Replace(" ", "_") + "Y");
                }
            }


            foreach (Picture shape in slide.Content.Drawings.OfType<Picture>())
            {
                Dictionary<string, string> properties = getProperties(null,shape.AlternativeText.Description);
                if (properties.ContainsKey("MOVEABLE") && properties.ContainsKey("NAME") && properties.ContainsKey("WASDMovement") == false && properties.ContainsKey("ARROWSMovement") == false && properties.ContainsKey("BOUNCING") == false)
                {
                    toReturn.Add(properties["NAME"].Replace(" ", "_") + "X");
                    toReturn.Add(properties["NAME"].Replace(" ", "_") + "Y");
                }
            }




            return toReturn;
        }


        void writeSquareShapeColor(StreamWriter writer, GemBox.Presentation.Color color,DrawingLayout scaledLayout,int tabs,LineFormat outline,bool borderEnabled, int allowedTransparencyLevel)
        {
            writer.WriteLine(getTabs(tabs) + "if(xPixel>" + (int)scaledLayout.Left.To(LengthUnit.Point) + " && xPixel<" + ((int)scaledLayout.Left.To(LengthUnit.Point) + (int)scaledLayout.Width.To(LengthUnit.Point)) +
                " && yPixel>" + (int)scaledLayout.Top.To(LengthUnit.Point) + " && yPixel<" + ((int)scaledLayout.Top.To(LengthUnit.Point) + (int)scaledLayout.Height.To(LengthUnit.Point)) + ")"+Environment.NewLine+getTabs(tabs)+"begin");

            if(allowedTransparencyLevel == 0 || color.A==255)  //No transparency allowed
            {
                writer.WriteLine(getTabs(tabs + 1) + "VGAr = " + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAg = " + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAb = " + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + ";");
            }
            else
            { 
                if(allowedTransparencyLevel == 1 || color.A > 125 && color.A < 130)  //Basic transparency (50/50) allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");  
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                }
                else  //Custom color based trnasparency allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(color.R*(color.A/255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100)+" * VGAr) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(color.G*(color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAg) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(color.B * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAb) / 100));");
                }
            }

            if(borderEnabled)
            {
                writer.Write(getTabs(tabs + 1) + "if(xPixel<" + Math.Round((int)scaledLayout.Left.To(LengthUnit.Point) + 0.668f * (int)outline.Width.To(LengthUnit.Point),0) + " || " +
                   "xPixel>" + Math.Round((int)scaledLayout.Left.To(LengthUnit.Point) + (int)scaledLayout.Width.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point),0) + " || "+
                    "yPixel<" + Math.Round((int)scaledLayout.Top.To(LengthUnit.Point) + 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                   "yPixel>" + Math.Round((int)scaledLayout.Top.To(LengthUnit.Point) + (int)scaledLayout.Height.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + ")");
                writer.WriteLine("    //Drawing border");

                
                writer.WriteLine(getTabs(tabs + 1) + "begin");

                SolidFillFormat outlineFill = (SolidFillFormat)outline.Fill;

                if (allowedTransparencyLevel == 0f || outlineFill.Color.A==255)
                {
                    writer.WriteLine(getTabs(tabs + 2) + "VGAr = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAg = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAb = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + ";");
                }
                else
                {
                    if (allowedTransparencyLevel==1 || outlineFill.Color.A > 125 && outlineFill.Color.A < 130)
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                    }
                    else
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.R * (outlineFill.Color.A/100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAr) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.G * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAg) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.B * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAb) / 100));");

                    }
                }

                writer.WriteLine(getTabs(tabs + 1) + "end");
            }

            writer.WriteLine(getTabs(tabs) + "end");
        }


        void writeSquareShapeColorMoveable(StreamWriter writer, GemBox.Presentation.Color color, DrawingLayout scaledLayout, int tabs, LineFormat outline, bool borderEnabled, int allowedTransparencyLevel,string name)
        {

            writer.WriteLine(getTabs(tabs) + "if(xPixel>"+name+"X && xPixel<"+name+"X+" + (int)scaledLayout.Width.To(LengthUnit.Point) +
                " && yPixel>"+name+"Y && yPixel<"+name+"Y+" + (int)scaledLayout.Height.To(LengthUnit.Point) + ")" + Environment.NewLine + getTabs(tabs) + "begin");

            if (allowedTransparencyLevel == 0 || color.A == 255)  //No transparency allowed
            {
                writer.WriteLine(getTabs(tabs + 1) + "VGAr = " + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAg = " + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAb = " + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + ";");
            }
            else
            {
                if (allowedTransparencyLevel == 1 || color.A > 125 && color.A < 130)  //Basic transparency (50/50) allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                }
                else  //Custom color based trnasparency allowed
                {
                    writer.WriteLine(getTabs(tabs + 1) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(color.R * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAr) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(color.G * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAg) / 100));");
                    writer.WriteLine(getTabs(tabs + 1) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(color.B * (color.A / 255.0)), 2).PadLeft(8, '0')) + " + ((" + (int)((color.A / 255.0) * 100) + " * VGAb) / 100));");
                }
            }

            if (borderEnabled)
            {
                writer.Write(getTabs(tabs + 1) + "if(xPixel<" + name + "X+" + Math.Round(0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                   "xPixel>" + name + "X+" + Math.Round((int)scaledLayout.Width.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                    "yPixel<" + name + "Y+" + Math.Round(0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + " || " +
                   "yPixel>" + name + "Y+" + Math.Round((int)scaledLayout.Height.To(LengthUnit.Point) - 0.668f * (int)outline.Width.To(LengthUnit.Point), 0) + ")");
                writer.WriteLine("    //Drawing border");


                writer.WriteLine(getTabs(tabs + 1) + "begin");

                SolidFillFormat outlineFill = (SolidFillFormat)outline.Fill;

                if (allowedTransparencyLevel == 0f || outlineFill.Color.A == 255)
                {
                    writer.WriteLine(getTabs(tabs + 2) + "VGAr = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAg = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + ";");
                    writer.WriteLine(getTabs(tabs + 2) + "VGAb = " + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + ";");
                }
                else
                {
                    if (allowedTransparencyLevel == 1 || outlineFill.Color.A > 125 && outlineFill.Color.A < 130)
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.R, 2).PadLeft(8, '0')) + " + VGAr) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.G, 2).PadLeft(8, '0')) + " + VGAg) / 2;");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString(outlineFill.Color.B, 2).PadLeft(8, '0')) + " + VGAb) / 2;");
                    }
                    else
                    {
                        writer.WriteLine(getTabs(tabs + 2) + "VGAr = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.R * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAr) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAg = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.G * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAg) / 100));");
                        writer.WriteLine(getTabs(tabs + 2) + "VGAb = (" + formatNumber("b", 8, Convert.ToString((int)(outlineFill.Color.B * (outlineFill.Color.A / 100)), 2).PadLeft(8, '0')) + " + ((" + (int)((outlineFill.Color.A / 100) * 100) + " * VGAb) / 100));");

                    }
                }

                writer.WriteLine(getTabs(tabs + 1) + "end");
            }

            writer.WriteLine(getTabs(tabs) + "end");
        }


        void writeMouse(StreamWriter writer, GemBox.Presentation.Color color, int tabs,Size size)
        {

            writer.WriteLine("\n" + getTabs(tabs) + "//Drawing the mouse");
            writer.WriteLine(getTabs(tabs) + "if(xPixel>mouseX && xPixel<(mouseX+"+size.Width+") && yPixel>mouseY && yPixel<(mouseY+"+size.Height+"))" + Environment.NewLine + getTabs(tabs) + "begin");

           
                writer.WriteLine(getTabs(tabs + 1) + "VGAr = " + formatNumber("b", 8, Convert.ToString(color.R, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAg = " + formatNumber("b", 8, Convert.ToString(color.G, 2).PadLeft(8, '0')) + ";");
                writer.WriteLine(getTabs(tabs + 1) + "VGAb = " + formatNumber("b", 8, Convert.ToString(color.B, 2).PadLeft(8, '0')) + ";");            
            

            writer.WriteLine(getTabs(tabs) + "end");
        }

        string formatNumber(string type,int length,string value)
        {
            return String.Format("{0}'{1}{2}",length,type,value);
        }

   
        private void saveProjectToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if(currentProjectFilePath=="")
            {
                if(saveFileDialog1.ShowDialog()==DialogResult.OK)
                {
                    currentProjectFilePath = saveFileDialog1.FileName;
                    currentProjectFolderPath = new FileInfo(currentProjectFilePath).Directory.FullName;
                }
            }

            if(currentProjectFilePath!="")
            {
                using (StreamWriter writer = new StreamWriter(currentProjectFilePath))
                {
                    if (textBoxProjectName.Text == "") textBoxProjectName.Text = Interaction.InputBox("Project name:", "Project name",new FileInfo(currentProjectFilePath).Directory.Name);
                    writer.WriteLine(textBoxProjectName.Text);
                    writer.WriteLine(checkBoxAutoCompile.Checked.ToString());
                }
            }
        }

        private void openProjectToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                currentProjectFilePath = openFileDialog1.FileName;
                currentProjectFolderPath = new FileInfo(currentProjectFilePath).Directory.FullName;
                using (StreamReader reader = new StreamReader(currentProjectFilePath))
                {
                    textBoxProjectName.Text = reader.ReadLine();
                    checkBoxAutoCompile.Checked = bool.Parse(reader.ReadLine());
                }
            }

            watcher = new FileSystemWatcher();
            watcher.Path = currentProjectFolderPath+ "/PPVerilogEngine";
            watcher.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite
               | NotifyFilters.FileName | NotifyFilters.DirectoryName;
            watcher.Filter = "*.pptx";

            // Add event handlers.
            watcher.Changed += new FileSystemEventHandler(OnChanged);
            watcher.Created += new FileSystemEventHandler(OnChanged);
            watcher.Deleted += new FileSystemEventHandler(OnChanged);
            watcher.Renamed += new RenamedEventHandler(OnChanged);

            // Begin watching.
            watcher.EnableRaisingEvents = true;
        }

        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            if(checkBoxAutoCompile.Checked)this.Invoke((MethodInvoker)delegate(){ button1.PerformClick(); });
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void button2_Click(object sender, EventArgs e)
        {
            SerialPortCom portCom = new SerialPortCom();
            portCom.Show();
        }
    }

    internal class MemoryBitmaps
    {
        public string name;
        public string x;
        public string y;       
        public Bitmap reducedBitmap;
        public int size;
        public int scale;
    }

    public class MovingProperties
    {
        public string name = "";
        public int width;
        public int height;
        public int speed;
     //   public bool memory = false;
    }

    public class MultiTextWriter : TextWriter
    {
        private IEnumerable<TextWriter> writers;
        public MultiTextWriter(IEnumerable<TextWriter> writers)
        {
            this.writers = writers.ToList();
        }
        public MultiTextWriter(params TextWriter[] writers)
        {
            this.writers = writers;
        }

        public override void Write(char value)
        {
            foreach (var writer in writers)
                writer.Write(value);
        }

        public override void Write(string value)
        {
            foreach (var writer in writers)
                writer.Write(value);
        }

        public override void Flush()
        {
            foreach (var writer in writers)
                writer.Flush();
        }

        public override void Close()
        {
            foreach (var writer in writers)
                writer.Close();
        }

        public override Encoding Encoding
        {
            get { return Encoding.ASCII; }
        }
    }

    public class ControlWriter : TextWriter
    {
        private Control textbox;
        public ControlWriter(Control textbox)
        {
            this.textbox = textbox;
        }

        public override void Write(char value)
        {
            textbox.Invoke((MethodInvoker)delegate () {
                textbox.Text += value;
            });            
        }

        public override void Write(string value)
        {
            textbox.Invoke((MethodInvoker)delegate () {
                textbox.Text += value;
            });
        }

        public override Encoding Encoding
        {
            get { return Encoding.ASCII; }
        }
    }
}
